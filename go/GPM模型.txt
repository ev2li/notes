一：调度器的由来
    多进程/多线程:
        进程和线程的数据越多,切换的成本就越大
    线程:
        协程调度器
        (N-1):协程阻塞(一个线程,一个协程调度器,N个协程)
        (N-M):N个线程,一个协程调度器,M个协程

    老的协程调度的问题：
        1.创建,销毁,调度G(goroutine)都需要每个M(系统线程)获取锁,这就形成了激烈的锁竞争
        2.M转移G会造成延迟和额外的系统负载
        3.系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销
     GMP模型:
        G -- goroutine协程 P -- processor处理器 M -- thread线程
        GOMAXPROCS-->LocalPqueue
        全局队列：存放等待运行的G
        P的本地队列：
            1.存放等待运行的G
            2.数量限制(不超过256G)
            3.优先将新创建的G放在P的本地队列中,如果满了会放在全局队列中
        P列表:
            1.程序启动时创建
            2.最大有GOMAXPROCS个(可配置)
                1)环境变量设置
                2)在程序中通过runtime.GOMAXPROCS()来设置
        M列表:
            1.当前操作系统分配到当前GO程序的内核线程数
            2.GO语言本身限定M的最大量1w(忽略)
            3.可以通过runtime/debug包中的setMaxThreads函数来设置
            4.有一个M阻塞,会创建一个新的M,如果有M空闲,那么会回收或者睡眠
    调度器的设计策略:
        1.复用线程:
            1.work stealing机制(偷)
                1.当本线程无可运行的G时,尝试从其他线程绑定的p偷取G,从而不销毁线程
            2.hand off机制(转移)
                1.当本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他空闲的线程执行
        2.利用并行
            1.GOMAXPROCS(cpu/2)
        3.抢占
            1.coroutine中要等待一个协程主动让出CPU才执行下一个协程
            2.在go中一个goroutine最多占用CPU10ms,防止其他goroutine被饿死
        4.全局队列
            1.当M执行work stealing从其他偷一到G时,它可以从全局队列获取G(要加锁)
    go指令的调用过程:
        1.通过go func()来创建一个goroutine
        2.新创建的G会优先保存到P的本地队列,如果P的本地队列已满就会保存到全局队列中
        3.G只能运行在M中,一个M必须有一个P,M和P是1:1的关系,M会从P的本地队列中弹出一个可执行状态的G
          来执行,如果P的本地队列为空,就会想从其他MP组合中偷取一个可执行的G来执行
        4.一个M调度G执行的过程是一个循环机制
        5.当M执行某个G时,如果发生了syscall或其他的阻塞操作时,M会阻塞,如果当前P中有一些G在执行,runtime
          会把这个线程M和P分离(detach),然后再创建一个新的操作系统线程(如果有空闲的线程可用就复用空闲线程)
          来服务于这个P
        6.当M系统调用结束的时候,这个G会尝试获取一个空闲的P执行,并放入到P的本地队列,如果获取不到P,那么这个
          线程M会变成休眠状态,加入到空闲线程中,然后这个G会被放入到全局队列中
    调度器的生命周期:
        1.M0:
            1.启动程序后编号为0的主线程
            2.在全局变量runtime.m0中,不需要heap上分配
            3.负责执行初始化操作和启动第一个G
            4.启动第一个G之后,m0就和其他的M一样了
        2.G0:
            1.每次启动一个M,都会第一个创建的goroutine,就是G0
            2.G0仅用于负责调度G
            3.G0不指向任何可执行的函数
            4.每个M都会有一个自己的G0
            5.在调度或系统调用时会使用M切换到G0,来调度
    GMP可视化:
        1.通过go tool trace工具打开trace文件
    场景：
        1.P拥有G1,M1获取P后开始运行G1,G1使用go func()创建了G2,为了局部性G2优先加入到P1的本地队列
        2.G1运行完成后(函数:goexit),M上运行的goroutine切换为G0,G0负责调度时协程的切换(函数schedule)
          从P的本地队列取G2,从G0切换到G2,并且开始运行G2(函数execute),实现线程M1的复用
        3.规定:在创建G时,运行的G会尝试唤醒其他空闲的P和M组合去执行,假定G2唤醒了M2,M2绑定了p2,并运行G0,
          但P2本地队列没有G,M2些时为自旋线程(没有G,就为运行状态状态的线程,不断寻找G)
        4.M2优先尝试从全局队列(简称"GQ")取一批G放到P2的本地队列(函数:findrunnable())
          M2从全局队列取的G数量,是使用公式 n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
        5.当M2取完了GQ里的G,再次调用G0,成为自旋线程,就要执行work stealing(偷取):从其他有G的P哪里偷取一半G
          过来，放到自己的本地队列,P2从P1的本地队列尾部取一半的G
        6.自旋线程 + 执行线程 <= GOMAXPROCS,多余的线程都放入到休眠线程队列中
        7.自旋线程是抢占G的不是抢占P的
        8.M2和P2会解绑,但M2会记住P2,然后G8和M2进入系统调用状态,当G8和M2退出系统调用时,会尝试获取P2,如果无法
          获取P2,则获取空闲的P,如果依然没有,G8会被记为可运行状态,并加入到全局队列,M2因为没有P绑定而变成休眠           状态(长时间休眠等待GC回收销毁)
