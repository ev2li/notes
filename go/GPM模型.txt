一：调度器的由来
    多进程/多线程:
        进程和线程的数据越多,切换的成本就越大
    线程:
        协程调度器
        (N-1):协程阻塞(一个线程,一个协程调度器,N个协程)
        (N-M):N个线程,一个协程调度器,M个协程

    老的协程调度的问题：
        1.创建,销毁,调度G(goroutine)都需要每个M(系统线程)获取锁,这就形成了激烈的锁竞争
        2.M转移G会造成延迟和额外的系统负载
        3.系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销
     GMP模型:
        G -- goroutine协程 P -- processor处理器 M -- thread线程
        GOMAXPROCS-->LocalPqueue
        全局队列：存放等待运行的G
        P的本地队列：
            1.存放等待运行的G
            2.数量限制(不超过256G)
            3.优先将新创建的G放在P的本地队列中,如果满了会放在全局队列中
        P列表:
            1.程序启动时创建
            2.最大有GOMAXPROCS个(可配置)
                1)环境变量设置
                2)在程序中通过runtime.GOMAXPROCS()来设置
        M列表:
            1.当前操作系统分配到当前GO程序的内核线程数
            2.GO语言本身限定M的最大量1w(忽略)
            3.可以通过runtime/debug包中的setMaxThreads函数来设置
            4.有一个M阻塞,会创建一个新的M,如果有M空闲,那么会回收或者睡眠
    调度器的设计策略:
        1.复用线程:
            1.work stealing机制(偷)
                1.当本线程无可运行的G时,尝试从其他线程绑定的p偷取G,从而不销毁线程
            2.hand off机制(转移)
                1.当本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他空闲的线程执行
        2.利用并行
            1.GOMAXPROCS(cpu/2)
        3.抢占
            1.coroutine中要等待一个协程主动让出CPU才执行下一个协程
            2.在go中一个goroutine最多占用CPU10ms,防止其他goroutine被饿死
        4.全局队列
            1.当M执行work stealing从其他偷一到G时,它可以从全局队列获取G(要加锁)
    go指令的调用过程:
        1.通过go func()来创建一个goroutine
        2.新创建的G会优先保存到P的本地队列,如果P的本地队列已满就会保存到全局队列中
        3.G只能运行在M中,一个M必须有一个P,M和P是1:1的关系,M会从P的本地队列中弹出一个可执行状态的G
          来执行,如果P的本地队列为空,就会想从其他MP组合中偷取一个可执行的G来执行
        4.一个M调度G执行的过程是一个循环机制
        5.当M执行某个G时,如果发生了syscall或其他的阻塞操作时,M会阻塞,如果当前P中有一些G在执行,runtime
          会把这个线程M和P分离(detach),然后再创建一个新的操作系统线程(如果有空闲的线程可用就复用空闲线程)
          来服务于这个P
        6.当M系统调用结束的时候,这个G会尝试获取一个空闲的P执行,并放入到P的本地队列,如果获取不到P,那么这个
          线程M会变成休眠状态,加入到空闲线程中,然后这个G会被放入到全局队列中
    调度器的生命周期:
        1.M0:
            1.启动程序后编号为0的主线程
            2.在全局变量runtime.m0中,不需要heap上分配
            3.负责执行初始化操作和启动第一个G
            4.启动第一个G之后,m0就和其他的M一样了
        2.G0:
            1.每次启动一个M,都会第一个创建的goroutine,就是G0
            2.G0仅用于负责调度G
            3.G0不指向任何可执行的函数
            4.每个M都会有一个自己的G0
            5.在调度或系统调用时会使用M切换到G0,来调度
    GMP可视化:
        1.通过go tool trace工具打开trace文件
