定义:
    1.读写锁一个读写锁同时只能存在一个写锁但可以存在多个读锁
    2.不能同时存在读锁和写锁

读写锁的三种状态:
    1.读模式下的加锁状态(读锁)
    2.写模式下的加锁状态(写锁)
    3.不加锁状态
读写锁的特性:
    1.读写锁是"写模式加锁时",解锁前,所有对该锁加锁的线程都会被阻塞
    2.读写锁是"读模式加锁时",如果线程以读模式对其加锁会成功,如果线程以写模式加锁会阻塞
    3.读写锁是"读模式加锁时",即有试图以写模式加锁的线程,也有试图以读模式加锁的线程,那么读写锁会阻塞随后读模式锁请求,优先满足写模式锁,读锁,写锁并行阻塞,写锁优先级高
    4.写独占,读共享,写锁优先级高

请求读锁(阻塞):
    1.如果写入器未持有读锁,并且没有任何写入器基于该锁阻塞,则调用线程会获取读锁
    2.如果写入器未持有读锁,但有多个写入器正在等待该锁时,调用线程是否能获取该锁是不确定的
    3.如果一个线程写锁定了,读写锁,又调用了pthread_rwlock_rdlock()来读锁定同一个读写锁,情况无法预测
    4.如果某个写入器持有该读锁,则调用线程无法获取该锁
    5.调用线程必须获取该锁之后,才能从pthread_rwlock_rdlock()返回
    6.为避免写入器资源匮乏,允许在多个实现中使写入器的优先级高于读写器
    7.ptrhead_rwlock_rdlock()n次,该线程必须调用pthread_rwlock_unlock()n次才能执行匹配的解除锁定的操作
    8.线程信号处理程序可以处理传送给等待读写锁的线程的信号,从信号处理程序返回后,线程将继续等待读写锁以执行读取,就好像线程未中断一样

请求写锁(阻塞):
    1.如果没有其他读取器线程或写入器线程持有读锁rwlock,则调用线程将获取写锁,否则,调用线程将阻塞
    2.调用线程必须获取该锁之后,才能从pthread_rwlock_wrlock()调用返回
    3.如果在进行调用时,调用线程持有读写锁(读锁或者写锁),则结果是不确定的
    4.为避免写入器资源匮乏,写入器的优先器高于读取器,如果针对未初始化的读写锁调用pthread_rwlock_wrlock(),则结果不确定的
    5.线程信号处理程序可以处理传送给等待读写锁以执行写入的线程信号,从信号处理程序返回后,线程将继续等待读写锁以执行写入,就好像线程未中断一样
互斥锁,读写锁和自旋锁的区别:
    1.互斥锁:用于保证任何时刻,都只能有一个线程访问对象,当获取锁操作失败时,线程会进入睡眠,等待锁释放时被唤醒
    2.读写锁:分为读锁和写锁,处于读操作时,可能允许多个线程同时获得读操作,但是同一时刻只能有一个线程可以获取写锁,其它获取写锁失败的线程都会进入睡眠状态,直到写锁释放时被唤醒.注意:写锁会阻塞其它读写锁,当有一个线程获得写锁在写时,读锁也不能被其它线程获取,写者优先于读者(一旦有写者,则后续读者必须等待,唤醒时优先考虑写者),适用于读取数据频率远大于写数据频率的场合
    3.自旋锁:在任何时刻同样只能有一个线程访问对象,但是当获取锁操作失败时,不会进入睡眠,而是会在原地自旋,直到锁释放,这样节省了线程从睡眠状态到唤醒期间的消耗,在加锁时间短暂的环境下会极大提高效率,但如果加锁时间过长,则会非常浪费cpu资源
